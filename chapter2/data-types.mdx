---
title: Data Types & Variables
description: Learn about Python's core data types and how to work with variables
---

# Data Types & Variables

In this section, we'll explore Python's built-in data types and how to work with variables. Understanding data types is fundamental to programming as they determine what operations you can perform on your data.

## Variables in Python

A variable is a name that refers to a value stored in the computer's memory. In Python, variables are created through assignment.

### Variable Assignment

```python
# Basic assignment
name = "Alice"
age = 30
height = 5.8
is_student = False

# Multiple assignment
x, y, z = 1, 2, 3

# Assigning the same value to multiple variables
a = b = c = 0
```

Unlike some other programming languages, Python doesn't require you to declare a variable's type before using it. The type is determined automatically based on the assigned value.

### Variable Naming Rules

As we saw in the previous section, variable names must follow these rules:
- Can contain letters, numbers, and underscores
- Cannot start with a number
- Cannot be a Python keyword
- Case-sensitive

### Variable Reassignment

Python variables can be reassigned to values of different types:

```python
x = 10        # x is an integer
print(x)      # 10

x = "Python"  # Now x is a string
print(x)      # Python

x = [1, 2, 3] # Now x is a list
print(x)      # [1, 2, 3]
```

This flexibility is due to Python's dynamic typing.

## Primitive Data Types

Python has several built-in data types. Let's start with the primitive ones:

### Numbers

Python supports several numeric types:

#### Integers (`int`)

Integers are whole numbers without a decimal point.

```python
a = 10
b = -5
c = 0
big_number = 1_000_000  # Underscores for readability in Python 3.6+
```

Integers in Python 3 have unlimited precision, meaning they can be as large as your computer's memory allows.

#### Floating-Point Numbers (`float`)

Floats are numbers with a decimal point or in scientific notation.

```python
x = 3.14
y = -0.001
z = 2.5e3       # Scientific notation: 2.5 * 10^3 = 2500.0
tiny = 1.7e-6   # 0.0000017
```

Floating-point numbers have limited precision and can sometimes produce unexpected results due to how they're stored in memory:

```python
print(0.1 + 0.2)  # 0.30000000000000004, not exactly 0.3
```

This isn't a Python bug but a consequence of binary floating-point representation used by most programming languages.

#### Complex Numbers (`complex`)

Complex numbers have a real and imaginary part.

```python
z = 2 + 3j   # j represents the imaginary part
w = complex(2, 3)  # Another way to create complex numbers
```

### Boolean (`bool`)

Boolean values represent truth values: `True` or `False`.

```python
is_raining = True
has_completed = False

# Booleans can be created from expressions
is_adult = age >= 18
is_valid = name != ""
```

In Python, Booleans are a subclass of integers. `True` is equivalent to 1, and `False` is equivalent to 0.

```python
print(True + True)  # 2
print(False * 10)   # 0
```

### None Type

`None` is a special constant in Python that represents the absence of a value or a null value. It's often used as a placeholder.

```python
result = None
print(result)  # None

# Checking for None
if result is None:
    print("No result yet")
```

Always use `is` or `is not` when comparing with `None`, not `==` or `!=`.

## String Data Type

### Strings (`str`)

Strings are sequences of characters enclosed in quotes (single, double, or triple quotes).

```python
name = "Alice"
message = 'Hello, Python!'
multiline = """This is a
multiline string
that spans multiple lines."""
```

### String Operations

Strings support various operations:

```python
# String concatenation (joining)
first_name = "John"
last_name = "Doe"
full_name = first_name + " " + last_name  # "John Doe"

# String repetition
repeated = "ha" * 3  # "hahaha"

# String length
name_length = len(name)  # 5

# Accessing characters by index (0-based)
first_char = name[0]  # "A"
last_char = name[-1]  # "e"

# Slicing strings
substring = name[1:3]  # "li" (from index 1 up to but not including 3)
first_three = name[:3]  # "Ali" (from beginning up to but not including 3)
after_second = name[2:]  # "ice" (from index 2 to the end)
```

### String Methods

Python strings have many useful methods:

```python
# Case conversion
print("hello".upper())       # "HELLO"
print("WORLD".lower())       # "world"
print("python".capitalize()) # "Python"
print("python".title())      # "Python"

# Finding substrings
print("hello world".find("world"))  # 6 (index where "world" starts)
print("hello world".count("l"))     # 3 (number of "l" characters)

# Checking string properties
print("abc123".isalnum())   # True (all alphanumeric)
print("abc".isalpha())      # True (all alphabet)
print("123".isdigit())      # True (all digits)
print("  ".isspace())       # True (all whitespace)

# Removing whitespace
print("  hello  ".strip())    # "hello" (remove leading and trailing whitespace)
print("  hello  ".lstrip())   # "hello  " (remove leading whitespace)
print("  hello  ".rstrip())   # "  hello" (remove trailing whitespace)

# Splitting and joining
words = "hello,world,python".split(",")  # ["hello", "world", "python"]
joined = "-".join(words)                # "hello-world-python"

# Replacing substrings
print("hello world".replace("world", "Python"))  # "hello Python"
```

### String Formatting

Python offers several ways to format strings:

#### f-strings (Python 3.6+, recommended)

```python
name = "Alice"
age = 30
print(f"My name is {name} and I am {age} years old.")
print(f"Next year, I'll be {age + 1} years old.")
```

#### str.format() method

```python
print("My name is {} and I am {} years old.".format(name, age))
print("My name is {0} and I am {1} years old.".format(name, age))
print("My name is {n} and I am {a} years old.".format(n=name, a=age))
```

#### % operator (older style)

```python
print("My name is %s and I am %d years old." % (name, age))
```

### String Immutability

Strings in Python are immutable, meaning once created, their contents cannot be changed. Any operation that seems to modify a string actually creates a new string.

```python
name = "Alice"
name[0] = "B"  # This will raise a TypeError

# Instead, create a new string
new_name = "B" + name[1:]  # "Blice"
```

## Collection Data Types

Python has several built-in collection types that can store multiple values.

### Lists (`list`)

Lists are ordered, mutable collections of items that can be of different types.

```python
# Creating lists
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14, True]
nested = [1, [2, 3], 4]
empty = []

# List comprehensions
squares = [x**2 for x in range(10)]  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

#### List Operations

```python
# Accessing elements
first = numbers[0]    # 1
last = numbers[-1]    # 5
sub_list = numbers[1:3]  # [2, 3]

# Modifying lists
numbers[0] = 10        # Change the first element
numbers.append(6)      # Add an element to the end
numbers.insert(0, 0)   # Insert 0 at the beginning
numbers.extend([7, 8]) # Add multiple elements to the end
numbers.remove(3)      # Remove the first occurrence of 3
popped = numbers.pop() # Remove and return the last element
popped_idx = numbers.pop(0)  # Remove and return the element at index 0

# List methods
numbers.sort()         # Sort the list in-place
numbers.reverse()      # Reverse the list in-place
count = numbers.count(5)  # Count occurrences of 5
index = numbers.index(4)  # Find the index of the first 4

# List operations
length = len(numbers)  # Number of elements
maximum = max(numbers) # Largest element
minimum = min(numbers) # Smallest element
total = sum(numbers)   # Sum of all elements

# Checking membership
is_present = 3 in numbers  # True if 3 is in the list
```

### Tuples (`tuple`)

Tuples are similar to lists, but they're immutable (cannot be changed after creation).

```python
# Creating tuples
coordinates = (10, 20)
person = ("Alice", 30, "Engineer")
single_item = (42,)  # Comma required for a single-item tuple
empty_tuple = ()

# Tuple unpacking
x, y = coordinates  # x=10, y=20
name, age, occupation = person  # name="Alice", age=30, occupation="Engineer"
```

Tuples are often used for:
- Returning multiple values from a function
- Dictionary keys (when lists can't be used)
- Data that shouldn't change

### Dictionaries (`dict`)

Dictionaries store key-value pairs, where keys must be unique and immutable.

```python
# Creating dictionaries
person = {"name": "Alice", "age": 30, "city": "New York"}
scores = {
    "Alice": 95,
    "Bob": 87,
    "Charlie": 92
}
empty_dict = {}
from_tuples = dict([("name", "Alice"), ("age", 30)])

# Dictionary comprehensions
square_map = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

#### Dictionary Operations

```python
# Accessing values
name = person["name"]       # "Alice" (raises KeyError if key doesn't exist)
age = person.get("age")      # 30
city = person.get("status", "Unknown")  # "Unknown" (default if key doesn't exist)

# Modifying dictionaries
person["email"] = "alice@example.com"  # Add a new key-value pair
person["age"] = 31                    # Update an existing value
person.update({"phone": "555-1234", "age": 32})  # Update multiple key-value pairs

# Removing items
removed = person.pop("city")  # Remove and return the value for "city"
person.popitem()            # Remove and return the last inserted key-value pair
del person["email"]         # Remove the "email" key-value pair
person.clear()              # Remove all items

# Dictionary methods
keys = scores.keys()        # Get all keys (as a view object)
values = scores.values()    # Get all values (as a view object)
items = scores.items()      # Get all key-value pairs (as a view object)

# Checking membership
has_key = "Alice" in scores  # True if "Alice" is a key in scores
```

### Sets (`set`)

Sets are unordered collections of unique elements.

```python
# Creating sets
fruits = {"apple", "banana", "cherry"}
numbers = {1, 2, 3, 4, 5}
mixed = {1, "hello", (1, 2)}  # Sets can contain immutable elements
empty_set = set()  # You cannot use {} to create an empty set (that creates an empty dict)

# Set comprehensions
even_numbers = {x for x in range(10) if x % 2 == 0}  # {0, 2, 4, 6, 8}
```

#### Set Operations

```python
# Modifying sets
fruits.add("orange")      # Add a single element
fruits.update({"grape", "kiwi"})  # Add multiple elements
fruits.remove("banana")   # Remove an element (raises KeyError if not found)
fruits.discard("pear")    # Remove an element if it exists (no error if not found)
popped = fruits.pop()     # Remove and return an arbitrary element
fruits.clear()            # Remove all elements

# Set operations
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}

union = a | b             # Union: elements in either a or b {1, 2, 3, 4, 5, 6}
intersection = a & b      # Intersection: elements in both a and b {3, 4}
difference = a - b        # Difference: elements in a but not in b {1, 2}
symmetric_diff = a ^ b    # Symmetric difference: elements in either a or b but not both {1, 2, 5, 6}

# Checking membership
contains = "apple" in fruits  # True if "apple" is in fruits
```

## Type Conversion

Python allows you to convert between different data types:

```python
# String conversions
str_to_int = int("123")         # 123
str_to_float = float("3.14")    # 3.14
int_to_str = str(456)           # "456"
float_to_str = str(7.89)        # "7.89"

# Numeric conversions
float_to_int = int(9.9)         # 9 (truncates, doesn't round)
int_to_float = float(42)        # 42.0

# Collection conversions
list_to_tuple = tuple([1, 2, 3])  # (1, 2, 3)
tuple_to_list = list((4, 5, 6))   # [4, 5, 6]
str_to_list = list("hello")       # ['h', 'e', 'l', 'l', 'o']
list_to_set = set([1, 2, 2, 3])   # {1, 2, 3} (removes duplicates)
```

## Type Checking

You can check the type of a variable using the `type()` function or the `isinstance()` function:

```python
x = 42
print(type(x))            # <class 'int'>
print(isinstance(x, int)) # True

y = "hello"
print(type(y))            # <class 'str'>
print(isinstance(y, int)) # False
```

## Variables and Memory

In Python, variable assignment doesn't copy data; it creates a reference to the data in memory.

```python
a = [1, 2, 3]
b = a  # b now refers to the same list as a

b.append(4)
print(a)  # [1, 2, 3, 4] - The change is visible through both variables
```

To create a copy of a mutable object, you need to use specific methods:

```python
# Shallow copy (copies the container but not nested objects)
a = [1, 2, [3, 4]]
b = a.copy()  # or b = list(a) or b = a[:]

b[0] = 5
print(a)  # [1, 2, [3, 4]] - The change to b doesn't affect a
b[2][0] = 7
print(a)  # [1, 2, [7, 4]] - The change to the nested list affects a

# Deep copy (copies everything)
import copy
a = [1, 2, [3, 4]]
b = copy.deepcopy(a)

b[2][0] = 7
print(a)  # [1, 2, [3, 4]] - The change to b doesn't affect a
```

## Mutability vs. Immutability

In Python, some data types are mutable (can be changed after creation), while others are immutable (cannot be changed after creation):

**Immutable types:**
- Numbers (int, float, complex)
- Strings (str)
- Tuples (tuple)
- Frozen sets (frozenset)
- Booleans (bool)

**Mutable types:**
- Lists (list)
- Dictionaries (dict)
- Sets (set)

Understanding mutability is important because it affects how variables behave when passed to functions or used as dictionary keys.

## Next Steps

Now that you understand Python's data types and variables, we'll move on to basic input and output operations in the next section. This will allow you to interact with users and display information from your programs.

---

## Practice Exercises

1. Create variables of each of the following types: integer, float, boolean, string, list, tuple, dictionary, and set. Print the value and type of each variable.

2. Create a list of your favorite fruits. Add a new fruit, remove one fruit, and modify another fruit in the list. Print the original and modified lists.

3. Create a dictionary with information about a person (name, age, city, etc.). Add a new key-value pair, update an existing value, and remove a key-value pair. Print the original and modified dictionaries.

4. Create two sets of numbers. Demonstrate union, intersection, difference, and symmetric difference operations. Print the results of each operation.

5. Create a nested data structure that combines at least three different types (e.g., a list of dictionaries, a dictionary with tuple keys and list values, etc.). Access and modify values at different levels of the structure. 